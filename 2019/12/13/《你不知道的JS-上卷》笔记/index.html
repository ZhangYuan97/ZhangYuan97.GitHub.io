<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="最近才开始读这套书，读完上卷就感觉获益匪浅，正好决定开始打理个人博客，就把看书的笔记上传作为第一篇博客吧，希望自己可以时时总结，温故知新。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="《你不知道的JS-上卷》笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;13&#x2F;%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-%E4%B8%8A%E5%8D%B7%E3%80%8B%E7%AC%94%E8%AE%B0&#x2F;index.html">
<meta property="og:site_name" content="ZhangYuan">
<meta property="og:description" content="最近才开始读这套书，读完上卷就感觉获益匪浅，正好决定开始打理个人博客，就把看书的笔记上传作为第一篇博客吧，希望自己可以时时总结，温故知新。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-13T06:49:59.956Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/12/13/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-%E4%B8%8A%E5%8D%B7%E3%80%8B%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>《你不知道的JS-上卷》笔记 | ZhangYuan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangYuan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/13/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-%E4%B8%8A%E5%8D%B7%E3%80%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="������">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangYuan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《你不知道的JS-上卷》笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-13 14:46:28 / 修改时间：14:49:59" itemprop="dateCreated datePublished" datetime="2019-12-13T14:46:28+08:00">2019-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>最近才开始读这套书，读完上卷就感觉获益匪浅，正好决定开始打理个人博客，就把看书的笔记上传作为第一篇博客吧，希望自己可以时时总结，温故知新。</p>
<a id="more"></a>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>ReferenceError，当变量不存在时，引用错误。<br>TypeError，类型错误，变量存在但尝试对这个变量进行不合理的操作。<br>ReferenceError作用域判别失败，TypeError代表作用域判别成功，但是对结果的操作是非法或不合理的。  </p>
<p>LHS和RHS：<br>如果查找的目的是对变量进行赋值，就使用LHS查询；<br>如果目的是获取变量的值，就会使用RHS查询。<br>LHS和RHS都会在当前作用域中进行查询，如果查询不到，就会向上级作用域继续查找，最后抵达全局作用域，无论找没找到都会停止。<br>不成功的LHS查询，在非严格模式下会自动隐式创建出一个全局变量，在严格模式下，会抛出ReferenceError错误；<br>不成功的RHS查询会抛出ReferenceError错误。</p>
<p>var a = 2的执行步骤：<br>1.在作用域中声明一个为a的新变量，这一步在代码执行前进行；<br>2.进行LHS查询变量a并对其进行赋值。  </p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><pre><code>function foo(str, a) {
    &quot;use strict&quot;;
    eval(str);
    console.log(a,b);     //2 10
}
var b = 1;
foo(&apos;var b = 10&apos;,2);</code></pre><p>在严格模式下，eval()无法修改所在的作用域。  </p>
<pre><code>function foo(str, a) {
    &quot;use strict&quot;;
    eval(str);
    console.log(a,b);    //2 1
}
var b = 1;
foo(&apos;var b = 10&apos;,2);</code></pre><p>with()函数同理。<br>但都不推荐使用，因为：<br>JS引擎会在编译阶段进行很多代码优化，其中有些优化依赖于“根据代码的词法进行静态分析，并预先确定好所有变量和函数的定义位置”，才能在执行过程中快速找到标识符，但如果代码中有这两个函数，就不能预测会接收到什么代码，这些代码会对作用域进行修改。所有的优化可能都是无意义的，性能会变慢。<br>粗略回答就是：1.性能慢 2.受严格模式影响。  </p>
<h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><p>函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。  </p>
<p>()即时函数：函数被当做函数表达式立即执行。  </p>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>提升即：无论作用域中声明出现在什么地方，都会在代码执行前被首先处理。<br>变量是先声明后赋值。每个作用域都会进行提升操作，但是函数声明会被提升，函数表达式不会被提升。</p>
<p>声明本身会被提升，但是包括函数表达式的赋值在内的赋值操作并不会被提升。</p>
<p>为什么不要在块内部声明函数，因为函数声明会被提升，一个普通块内部的函数声明通常会被提升到所在的作用域顶部，也不会被条件判断控制。  </p>
<p><code>var a = 2</code><br>实际上分为2段，第一个是编译阶段的任务；第二个是执行阶段的任务（进行赋值）  </p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>当函数在当前词法作用域之外执行，就产生了闭包。<br>无论通过何种手段将内部函数传递到所在的词法作用域外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。  </p>
<pre><code>for(var i = 1; i &lt;= 5; i++){
    (function(i){
        setTimeout(function(){
            console.log(i);
        }, 1000*i)
    })(i);
}  //1 2 3 4 5</code></pre><p>在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封在每个迭代内部，每个迭代内部都有一个含有正确值的变量供我们访问。  </p>
<h3 id="块级作用域的替代方案"><a href="#块级作用域的替代方案" class="headerlink" title="块级作用域的替代方案"></a>块级作用域的替代方案</h3><p>使用代码转换工具对ES6代码进行处理，生成兼容ES5的代码。<code>Traceur</code></p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。<br>调用位置全意就是，函数在代码中被调用的位置。<br>最重要的是分析调用栈，才能正确分析出this的指向。  </p>
<p>对象属性引用链中只有最后一层会影响调用位置：  </p>
<pre><code>function show(){
    console.log(this.color);
}
var color = &quot;red&quot;;
var obj2 = {
    color: &quot;yellow&quot;,
    show: show
};
var obj3 = {
    color: &quot;blue&quot;,
    obj2: obj2
}
show();  //red
obj2.show();  //yellow
obj3.obj2.show();  //yellow</code></pre><p>显式绑定</p>
<pre><code>function foo5() {
    console.log(this.m);
}
var obj5 = {
    m: 11
};
foo5.call(obj5);  //11</code></pre><p>this绑定的规则：<br>1.函数在new中调用，this绑定的是新创建的对象<br>2.函数通过call、apply（显示绑定）或硬绑定调用，this绑定的是指定的对象<br>3.函数在某个上下文中调用（隐式绑定），this绑定的是那个上下文对象<br>4.如果都不是的话是默认绑定，在严格模式下绑定到undefined，非严格模式，绑定到全局对象  </p>
<p>this中的例外</p>
<pre><code>//1.间接引用
function foo8(){
    console.log(this.aa);
}
var aa = 5;
var obj8 = {
    aa: 6,
    foo8: foo8
};
var p = {
    aa: 7
};
obj8.foo8();  //6
(p.foo8 = obj8.foo8)();  //5
//这个赋值表达式的的返回值是目标函数的引用，因此调用的是foo8而不是obj8.foo8()

//2.传入null或undefined
function foo9(){
    console.log(this.bb);
}
var bb = &apos;bb&apos;;
foo9.call(null);  // bb
//把undefined或null作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，应用默认的绑定规则

//在什么情况下会传入null
//2.1把数组展开为参数，类似ES6中的...扩展运算符
function fooA(a,b){
    console.log(&quot;a:&quot;+a+&quot; b:&quot;+b);
}
fooA.apply(null,[2,3]);  //a:2 b:3
fooA(...[2,3]);  //a:2 b:3

//2.2使用bind进行柯里化（预先设置一些参数）
var obja = fooA.bind(null,2);
obja(3);  //a:2 b:3

//即当函数并不关心this的时候，仍然需要传入一个占位符，可以用null，但最好使用一个新创建的空对象
//Object.create(null),虽然也是创建新对象，但是不会像{}这样创建prototype</code></pre><p>ES6中的箭头函数不遵循上面的规则，而是根据外层（函数或全局）作用域来决定this。箭头函数创建时属于谁，this就指向谁，箭头函数的绑定无法被修改。  </p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>基本简单类型本身不是对象。null有时会被当做一种对象类型，但是null并不是对象，出现这个问题的原因是：对象在底层是二进制表示的，在JS中前三位都为0的二进制会被判断为object类型，而null的二进制全是0，所以会被typeof当成objet。  </p>
<p>如何判断null：  </p>
<pre><code>var a1 = null;
if(typeof(a1) != &quot;undefined&quot; &amp;&amp; !a1 &amp;&amp; a1 != 0){
    console.log(&apos;a1 is null&apos;);
}</code></pre><p>typeof的返回值有：object function boolean number string undefined</p>
<p>//使用instanceof判断一个实例是否属于某种类型<br>//在继承关系中用来判断一个实例是否属于它的父类型</p>
<pre><code>var s1 = &quot;hello&quot;;
console.log(typeof s1);  //string
console.log(s1 instanceof String);  //false

var s2 = new String(&quot;hello&quot;);
console.log(typeof s2);  //objece
console.log(s2 instanceof String);  //true</code></pre><p>//属性描述符</p>
<pre><code>var myobj = {
    a: 10
}
var dec = Object.getOwnPropertyDescriptor(myobj, &quot;a&quot;);
console.log(dec);
Object.defineProperty(myobj, &quot;b&quot;, {
    value: 20,
    writable: true,
    enumerable: true,
    configurable: true
})
console.log(myobj.b); //20</code></pre><p>将对象的writable和configurable设置为false，可创建一个真正的常量属性，不可修改，不可重定义，不可删除。<br>禁止拓展：Object.preventExtensions()，禁止对象添加新属性但是可以保留已有属性。<br>密封：Object.seal()，不能添加新属性，也不能重新配置和删除现有属性。<br>冻结：Object.freeze()，禁止对象修改，是级别最高的不可变性  </p>
<p>可枚举性：enumerable，相当于可以出现在对象属性的遍历中。<br>检查属性是否可枚举：<code>obj.propertyIsEnumerable(&quot;name&quot;);</code>，检查给定的属性名是否直接存在对象中并且是可枚举的。  </p>
<p>在不访问属性值的情况下判断对象中是否存在某属性：<br>1.in操作符，<code>&quot;name&quot; in obj</code><br>2.<code>obj.hasOwnproperty(&quot;name&quot;)</code><br>in会检查属性名是否在对象及其原型链中国年；hasOwnProperty()只会检查属性是否在给定的对象中，不会检查原型链。  </p>
<p>Object.keys()会返回对象的所有可枚举属性（不包括原型链），Object.getOwnPropertyNames()返回对象的所有属性，不管是否可枚举，也不包括原型链。  </p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p><code>Foo.prototype.isPrototypeOf(a)</code>:判断在a的整条链中是否出现过Foo.prototype<br>Prototype机制就是存在于对象中的一个内部链接，它会引用其他对象。  </p>
<p>Object.create()会创建一个对象并把它关联到指定的对象，而使用new的构造函数调用会生成prototype和constructor引用。  </p>
<p>//模拟Object.create()</p>
<pre><code>if(!Object.create){
    Object.create = function(o){
        function F(){}
        F.prototype = o;
        return new F();
    }
}</code></pre><p>toString()、valueOf()和其他一些通用的功能都存在于Object.prototype上，因此语言中的所有对象都可以使用他们。  </p>
<p>在使用new调用函数时会把新对象的prototype属性关联到其他对象，带new的函数调用通常被称为构造函数调用；它们实际上和传统面向类语言中的类构造函数不一样。<br>因为JS的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的prototype链来关联的。  </p>
<p>使用new来调用函数时的过程：<br>1.创建一个全新的对象<br>2.这个新对象会被执行原型连接<br>3.这个新对象会绑定到函数调用的this<br>4.如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象  </p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托行为意味着在找不到属性或方法引用时，会把这个请求委托给另一个对象。  </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/06/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">1.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词法作用域"><span class="nav-number">2.</span> <span class="nav-text">词法作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作用域和块作用域"><span class="nav-number">3.</span> <span class="nav-text">函数作用域和块作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提升"><span class="nav-number">4.</span> <span class="nav-text">提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">5.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#块级作用域的替代方案"><span class="nav-number">6.</span> <span class="nav-text">块级作用域的替代方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">7.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">8.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联"><span class="nav-number">9.</span> <span class="nav-text">关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#委托"><span class="nav-number">10.</span> <span class="nav-text">委托</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">������</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">������</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
